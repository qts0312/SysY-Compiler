//! # Asm
//! 
//! In this file, we define core part of my compiler.
//! We use the program and information generated by the `mem` module to generate assembly code.
//! 

use crate::asm::scope::{ Scope, Entry, new_register };
use crate::asm::writer::Writer;
use crate::tools::get_size_form_ty;
use crate::mem::info::Info;
use koopa::ir::{ Program, FunctionData, Value, ValueKind, TypeKind, BinaryOp };
use koopa::ir::entities::ValueData;
use koopa::ir::values::{ Integer, Return, Binary, Alloc };

pub trait Asm {
    fn asm(&self, program: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info);
}

impl Asm for Program {
    fn asm(&self, program: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        // data section
        w.note("  .data");
        for value in self.inst_layout() {
            scope.set_cur_value(Some(value.clone()));
            program.borrow_value(value.clone()).asm(program, scope, w, info);
        }

        w.line();
        w.line();

        // text section
        w.note("  .text");
        for func in self.func_layout() {
            scope.set_cur_func(Some(func.clone()));
            program.func(func.clone()).asm(program, scope, w, info);
        }
    }
}

impl Asm for FunctionData {
    fn asm(&self, program: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        if let None = self.layout().entry_bb() {
            return;
        }

        let mut slots = 0;
        let mut max_args = 0;
        for (_, value) in self.dfg().values() {
            match value.kind() {
                ValueKind::Alloc(_) => {
                    match value.ty().kind() {
                        TypeKind::Pointer(base) => {
                            match base.kind() {
                                TypeKind::Int32 => slots += 1,
                                TypeKind::Array(_, _) => slots += get_size_form_ty(base),
                                TypeKind::Pointer(_) => slots += 1,
                                _ => panic!("in my compiler, only allocat int32, array and pointer")
                            }
                        }
                        _ => panic!("we expect allocate value should be pointer type")
                    }
                }
                ValueKind::Load(_) => slots += 1,
                ValueKind::Binary(_) => slots += 1,
                ValueKind::Call(call) => {
                    slots += 2;
                    scope.set_caller(true);
                    max_args = max_args.max(call.args().len());
                }
                ValueKind::GetElemPtr(_) => slots += 1,
                ValueKind::GetPtr(_) => slots += 1,
                _ => {}
            }
        }

        slots = slots + max_args.max(8) - 8;
        slots = if slots % 4 == 0 { slots } else { slots + 4 - slots % 4 };
        scope.set_total_slots(slots);
        scope.set_used_slots(max_args.max(8) - 8);

        let name = self.name()[1..].to_string();
        w.prologue(&name, scope);

        let mut with_ret = false;
        let mut current = 0;
        for (bb, node) in self.layout().bbs() {
            let name = self.dfg().bb(bb.clone()).name().as_ref().unwrap()[1..].to_string();
            if name != "entry" {
                w.note(&format!("{}:", name));
            }

            for(value, _) in node.insts() {
                if let ValueKind::Return(_) = self.dfg().value(value.clone()).kind() {
                    with_ret = true;
                }
                current = info.info(value.clone()).unwrap().birth;
                scope.set_cur_value(Some(value.clone()));
                self.dfg().value(value.clone()).asm(program, scope, w, info);

                // after a value, all the value dead before current should be removed from registers
                for register in scope.registers_mut() {
                    match register.value {
                        Some(value) => {
                            if info.info(value.clone()).unwrap().death <= current {
                                register.used = false;
                                register.value = None;
                            }
                        }
                        None => {}
                    }
                }
            }

            // after a block, all the registers should be free and all the values in registers should be spilled
            let mut values: Vec<(String, Value)> = vec![];
            for register in scope.registers_mut() {
                match register.value {
                    Some(value) => {
                        register.used = false;
                        register.value = None;
                        values.push((register.name().to_string(), value.clone()));
                    }
                    None => {}
                }
            }

            for (name, value) in values {
                let slot = scope.new_slot();
                w.op2("sw", &name, &format!("{}(sp)", slot * 4));
                scope.new_value(value, Entry::Slot(slot));
            }
        }

        if with_ret == false {
            w.epilogue(scope);
        }

        w.line();
        w.line();
    }
}

impl Asm for ValueData {
    fn asm(&self, program: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        match self.kind() {
            ValueKind::Integer(integer) => integer.asm(program, scope, w, info),
            ValueKind::Return(ret) => ret.asm(program, scope, w, info),
            ValueKind::Binary(binary) => binary.asm(program, scope, w, info),
            ValueKind::Alloc(alloc) => alloc.asm(program, scope, w, info),
            // ValueKind::Load(load) => load.asm(program, scope, w, info),
            // ValueKind::Store(store) => store.asm(program, scope, w, info),
            // ValueKind::Branch(branch) => branch.asm(program, scope, w, info),
            // ValueKind::Jump(jump) => jump.asm(program, scope, w, info),
            // ValueKind::Call(call) => call.asm(program, scope, w, info),
            // ValueKind::GlobalAlloc(global_alloc) => global_alloc.asm(program, scope, w, info),
            // ValueKind::GetElemPtr(get_elem_ptr) => get_elem_ptr.asm(program, scope, w, info),
            // ValueKind::GetPtr(get_ptr) => get_ptr.asm(program, scope, w, info),
            _ => panic!("not support this value")
        }
    }
}

impl Asm for Integer {
    fn asm(&self, _: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        if self.value() == 0 {
            scope.new_value(scope.cur_value().clone(), Entry::Register("x0".to_string()));
        }
        else {
            let value = scope.cur_value().clone();
            let current = info.info(scope.cur_value().clone()).unwrap().birth;
            let register = new_register!(scope, w);
            register.used = true;
            register.stamp = current;
            register.value = Some(value.clone());

            w.op2("li", &register.name(), &format!("{}", self.value()));

            let name = register.name().to_string();
            scope.new_value(value.clone(), Entry::Register(name));
        }
    }
}

impl Asm for Return {
    fn asm(&self, _: &Program, scope: &mut Scope, w: &mut Writer, _: &mut Info) {
        if let Some(value) = self.value() {
            let entry = scope.value(&value).clone();
            match entry {
                Entry::Slot(slot) => w.op2("lw", "a0", &format!("{}(sp)", slot * 4)),
                Entry::Register(name) => w.op2("mv", "a0", &name),
                Entry::Label(label) => {
                    let temporary = scope.new_register(w);
                    w.op2("la", temporary.name(), &label);
                    w.op2("lw", "a0", &format!("0({})", temporary.name()));
                }
            }
        }
        w.epilogue(scope);
    }
}

impl Asm for Binary {
    fn asm(&self, _: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        let entry = scope.value(&self.lhs()).clone();
        let lhs = match entry {
            Entry::Slot(slot) => {
                let temporary = scope.new_register(w);
                w.op2("lw", temporary.name(), &format!("{}(sp)", slot * 4));
                temporary.name().to_string()
            }
            Entry::Register(name) => name.to_string(),
            Entry::Label(label) => {
                let temporary = scope.new_register(w);
                w.op2("la", temporary.name(), &label);
                w.op2("lw", temporary.name(), &format!("0({})", temporary.name()));
                temporary.name().to_string()
            }
        };
        let entry = scope.value(&self.rhs()).clone();
        let rhs = match entry {
            Entry::Slot(slot) => {
                let temporary = scope.new_register(w);
                w.op2("lw", temporary.name(), &format!("{}(sp)", slot * 4));
                temporary.name().to_string()
            }
            Entry::Register(name) => name.to_string(),
            Entry::Label(label) => {
                let temporary = scope.new_register(w);
                w.op2("la", temporary.name(), &label);
                w.op2("lw", temporary.name(), &format!("0({})", temporary.name()));
                temporary.name().to_string()
            }
        };
        let value = scope.cur_value().clone();
        let register = new_register!(scope, w);
        register.used = true;
        register.stamp = info.info(value.clone()).unwrap().birth;
        register.value = Some(value.clone());

        match self.op() {
            BinaryOp::Add => w.op3("add", register.name(), &lhs, &rhs),
            BinaryOp::Sub => w.op3("sub", register.name(), &lhs, &rhs),
            BinaryOp::Mul => w.op3("mul", register.name(), &lhs, &rhs),
            BinaryOp::Div => w.op3("div", register.name(), &lhs, &rhs),
            BinaryOp::Mod => w.op3("rem", register.name(), &lhs, &rhs),
            BinaryOp::And => w.op3("and", register.name(), &lhs, &rhs),
            BinaryOp::Or => w.op3("or", register.name(), &lhs, &rhs),
            BinaryOp::Eq => {
                w.op3("sub", register.name(), &lhs, &rhs);
                w.op2("seqz", register.name(), register.name());
            }
            BinaryOp::NotEq => {
                w.op3("sub", register.name(), &lhs, &rhs);
                w.op2("snez", register.name(), register.name());
            }
            BinaryOp::Lt => w.op3("slt", register.name(), &lhs, &rhs),
            BinaryOp::Gt => w.op3("sgt", register.name(), &lhs, &rhs),
            BinaryOp::Le => {
                w.op3("sgt", register.name(), &lhs, &rhs);
                w.op2("seqz", register.name(), register.name());
            }
            BinaryOp::Ge => {
                w.op3("slt", register.name(), &lhs, &rhs);
                w.op2("seqz", register.name(), register.name());
            }
            _ => panic!("not support this binary operation")
        }

        let name = register.name().to_string();
        scope.new_value(scope.cur_value().clone(), Entry::Register(name));
    }
}

impl Asm for Alloc {
    fn asm(&self, program: &Program, scope: &mut Scope, w: &mut Writer, info: &mut Info) {
        let func = scope.cur_func().clone();
        let value = scope.cur_value().clone();
        let size = match program.func(func).dfg().value(value.clone()).ty().kind() {
            TypeKind::Pointer(base) => {
                match base.kind() {
                    TypeKind::Int32 => 1,
                    TypeKind::Array(_, _) => get_size_form_ty(base),
                    TypeKind::Pointer(_) => 1,
                    _ => panic!("in my compiler, only allocat int32, array and pointer")
                }
            }
            _ => panic!("we expect allocate value should be pointer type")
        };

        let slot = scope.new_slots(size);
        scope.new_value(value, Entry::Slot(slot));
    }
}
